// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fixpoint from "../bindings/Fixpoint.res.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";
import * as Primitive_string from "@rescript/runtime/lib/es6/Primitive_string.js";

let testCount = {
  contents: 0
};

let passCount = {
  contents: 0
};

let failCount = {
  contents: 0
};

function sortedArray(arr) {
  return arr.toSorted(Primitive_string.compare);
}

function assertEqual(name, actual, expected) {
  testCount.contents = testCount.contents + 1 | 0;
  let actualSorted = sortedArray(actual);
  let expectedSorted = sortedArray(expected);
  let pass = Primitive_object.equal(actualSorted, expectedSorted);
  if (pass) {
    passCount.contents = passCount.contents + 1 | 0;
    console.log("✓ " + name);
  } else {
    failCount.contents = failCount.contents + 1 | 0;
    console.log("✗ " + name);
    console.log("  Expected:", expectedSorted);
    console.log("  Actual:  ", actualSorted);
  }
}

function assertSize(name, actual, expected) {
  testCount.contents = testCount.contents + 1 | 0;
  if (actual === expected) {
    passCount.contents = passCount.contents + 1 | 0;
    console.log("✓ " + name);
  } else {
    failCount.contents = failCount.contents + 1 | 0;
    console.log("✗ " + name);
    console.log("  Expected:", expected);
    console.log("  Actual:  ", actual);
  }
}

function assertTrue(name, actual) {
  testCount.contents = testCount.contents + 1 | 0;
  if (actual) {
    passCount.contents = passCount.contents + 1 | 0;
    console.log("✓ " + name);
  } else {
    failCount.contents = failCount.contents + 1 | 0;
    console.log("✗ " + name);
    console.log("  Expected: true, Actual: false");
  }
}

function assertFalse(name, actual) {
  testCount.contents = testCount.contents + 1 | 0;
  if (actual) {
    failCount.contents = failCount.contents + 1 | 0;
    console.log("✗ " + name);
    console.log("  Expected: false, Actual: true");
  } else {
    passCount.contents = passCount.contents + 1 | 0;
    console.log("✓ " + name);
  }
}

function makeConfig(edges) {
  return {
    stepFwdForEach: (source, f) => {
      let targets = edges.get(source);
      if (targets !== undefined) {
        targets.forEach(f);
        return;
      }
    }
  };
}

function makeEdges(edgeList) {
  let edges = new Map();
  edgeList.forEach(param => {
    edges.set(param[0], new Set(param[1]));
  });
  return edges;
}

function testBasicExpansion() {
  console.log("");
  console.log("=== Test: Basic Expansion ===");
  let edges = makeEdges([
    [
      "a",
      ["b"]
    ],
    [
      "b",
      ["c"]
    ]
  ]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Initial fixpoint contains a, b, c", Fixpoint.current(state), [
    "a",
    "b",
    "c"
  ]);
  assertSize("Size is 3", Fixpoint.size(state), 3);
  assertTrue("Has a", Fixpoint.has(state, "a"));
  assertTrue("Has b", Fixpoint.has(state, "b"));
  assertTrue("Has c", Fixpoint.has(state, "c"));
  assertFalse("Does not have d", Fixpoint.has(state, "d"));
}

function testMultipleRoots() {
  console.log("");
  console.log("=== Test: Multiple Roots ===");
  let edges = makeEdges([
    [
      "a",
      ["b"]
    ],
    [
      "c",
      ["d"]
    ]
  ]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, [
    "a",
    "c"
  ]);
  assertEqual("Contains both components", Fixpoint.current(state), [
    "a",
    "b",
    "c",
    "d"
  ]);
}

function testDiamond() {
  console.log("");
  console.log("=== Test: Diamond Graph ===");
  let edges = makeEdges([
    [
      "a",
      [
        "b",
        "c"
      ]
    ],
    [
      "b",
      ["d"]
    ],
    [
      "c",
      ["d"]
    ]
  ]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Contains all nodes", Fixpoint.current(state), [
    "a",
    "b",
    "c",
    "d"
  ]);
  let r = Fixpoint.rank(state, "a");
  if (r !== undefined) {
    assertSize("Rank of a is 0", r, 0);
  } else {
    assertTrue("Rank of a should exist", false);
  }
  let r$1 = Fixpoint.rank(state, "d");
  if (r$1 !== undefined) {
    return assertSize("Rank of d is 2", r$1, 2);
  } else {
    return assertTrue("Rank of d should exist", false);
  }
}

function testCycle() {
  console.log("");
  console.log("=== Test: Cycle ===");
  let edges = makeEdges([
    [
      "a",
      ["b"]
    ],
    [
      "b",
      ["c"]
    ],
    [
      "c",
      ["b"]
    ]
  ]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Contains a, b, c", Fixpoint.current(state), [
    "a",
    "b",
    "c"
  ]);
}

function testAddBase() {
  console.log("");
  console.log("=== Test: Add Base Element ===");
  let edges = makeEdges([
    [
      "a",
      ["b"]
    ],
    [
      "c",
      ["d"]
    ]
  ]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Initial: a, b", Fixpoint.current(state), [
    "a",
    "b"
  ]);
  let init = Fixpoint.emptyDelta();
  let changes = Fixpoint.applyDelta(state, {
    addedToBase: ["c"],
    removedFromBase: init.removedFromBase,
    addedToStep: init.addedToStep,
    removedFromStep: init.removedFromStep
  });
  assertEqual("Added c, d", changes.added, [
    "c",
    "d"
  ]);
  assertEqual("Nothing removed", changes.removed, []);
  assertEqual("Final: a, b, c, d", Fixpoint.current(state), [
    "a",
    "b",
    "c",
    "d"
  ]);
}

function testRemoveBase() {
  console.log("");
  console.log("=== Test: Remove Base Element ===");
  let edges = makeEdges([
    [
      "a",
      ["b"]
    ],
    [
      "b",
      ["c"]
    ]
  ]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Initial: a, b, c", Fixpoint.current(state), [
    "a",
    "b",
    "c"
  ]);
  let init = Fixpoint.emptyDelta();
  let changes = Fixpoint.applyDelta(state, {
    addedToBase: init.addedToBase,
    removedFromBase: ["a"],
    addedToStep: init.addedToStep,
    removedFromStep: init.removedFromStep
  });
  assertEqual("Nothing added", changes.added, []);
  assertEqual("Removed a, b, c", changes.removed, [
    "a",
    "b",
    "c"
  ]);
  assertEqual("Final: empty", Fixpoint.current(state), []);
}

function testAddStep() {
  console.log("");
  console.log("=== Test: Add Step (Edge) ===");
  let edges = new Map();
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Initial: just a", Fixpoint.current(state), ["a"]);
  edges.set("a", new Set(["b"]));
  let init = Fixpoint.emptyDelta();
  let changes = Fixpoint.applyDelta(state, {
    addedToBase: init.addedToBase,
    removedFromBase: init.removedFromBase,
    addedToStep: [[
        "a",
        "b"
      ]],
    removedFromStep: init.removedFromStep
  });
  assertEqual("Added b", changes.added, ["b"]);
  assertEqual("Final: a, b", Fixpoint.current(state), [
    "a",
    "b"
  ]);
}

function testRemoveStep() {
  console.log("");
  console.log("=== Test: Remove Step (Edge) ===");
  let edges = makeEdges([
    [
      "a",
      ["b"]
    ],
    [
      "b",
      ["c"]
    ]
  ]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Initial: a, b, c", Fixpoint.current(state), [
    "a",
    "b",
    "c"
  ]);
  edges.delete("a");
  let init = Fixpoint.emptyDelta();
  let changes = Fixpoint.applyDelta(state, {
    addedToBase: init.addedToBase,
    removedFromBase: init.removedFromBase,
    addedToStep: init.addedToStep,
    removedFromStep: [[
        "a",
        "b"
      ]]
  });
  assertEqual("Nothing added", changes.added, []);
  assertEqual("Removed b, c", changes.removed, [
    "b",
    "c"
  ]);
  assertEqual("Final: just a", Fixpoint.current(state), ["a"]);
}

function testCycleRemoval() {
  console.log("");
  console.log("=== Test: Cycle Removal (Well-Founded) ===");
  let edges = makeEdges([
    [
      "a",
      ["b"]
    ],
    [
      "b",
      ["c"]
    ],
    [
      "c",
      ["b"]
    ]
  ]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Initial: a, b, c", Fixpoint.current(state), [
    "a",
    "b",
    "c"
  ]);
  edges.set("a", new Set());
  let init = Fixpoint.emptyDelta();
  let changes = Fixpoint.applyDelta(state, {
    addedToBase: init.addedToBase,
    removedFromBase: init.removedFromBase,
    addedToStep: init.addedToStep,
    removedFromStep: [[
        "a",
        "b"
      ]]
  });
  assertEqual("Removed b, c (cycle dies)", changes.removed, [
    "b",
    "c"
  ]);
  assertEqual("Final: just a", Fixpoint.current(state), ["a"]);
}

function testAlternativeSupport() {
  console.log("");
  console.log("=== Test: Alternative Support ===");
  let edges = makeEdges([
    [
      "a",
      [
        "b",
        "c"
      ]
    ],
    [
      "c",
      ["b"]
    ]
  ]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Initial: a, b, c", Fixpoint.current(state), [
    "a",
    "b",
    "c"
  ]);
  edges.set("a", new Set(["c"]));
  let init = Fixpoint.emptyDelta();
  let changes = Fixpoint.applyDelta(state, {
    addedToBase: init.addedToBase,
    removedFromBase: init.removedFromBase,
    addedToStep: init.addedToStep,
    removedFromStep: [[
        "a",
        "b"
      ]]
  });
  assertEqual("Nothing removed (b still reachable via c)", changes.removed, []);
  assertEqual("Final: a, b, c", Fixpoint.current(state), [
    "a",
    "b",
    "c"
  ]);
}

function testEmptyBase() {
  console.log("");
  console.log("=== Test: Empty Base ===");
  let edges = makeEdges([[
      "a",
      ["b"]
    ]]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, []);
  assertEqual("Empty base gives empty fixpoint", Fixpoint.current(state), []);
  assertSize("Size is 0", Fixpoint.size(state), 0);
}

function testSelfLoop() {
  console.log("");
  console.log("=== Test: Self Loop ===");
  let edges = makeEdges([[
      "a",
      ["a"]
    ]]);
  let config = makeConfig(edges);
  let state = Fixpoint.make(config, ["a"]);
  assertEqual("Self loop: just a", Fixpoint.current(state), ["a"]);
}

function runTests() {
  console.log("Fixpoint Tests");
  console.log("===============");
  testBasicExpansion();
  testMultipleRoots();
  testDiamond();
  testCycle();
  testAddBase();
  testRemoveBase();
  testAddStep();
  testRemoveStep();
  testCycleRemoval();
  testAlternativeSupport();
  testEmptyBase();
  testSelfLoop();
  console.log("");
  console.log("===============");
  console.log("Total:", testCount.contents);
  console.log("Passed:", passCount.contents);
  console.log("Failed:", failCount.contents);
  if (failCount.contents > 0) {
    console.log("");
    console.log("SOME TESTS FAILED!");
  } else {
    console.log("");
    console.log("ALL TESTS PASSED!");
  }
}

runTests();

export {
  testCount,
  passCount,
  failCount,
  sortedArray,
  assertEqual,
  assertSize,
  assertTrue,
  assertFalse,
  makeConfig,
  makeEdges,
  testBasicExpansion,
  testMultipleRoots,
  testDiamond,
  testCycle,
  testAddBase,
  testRemoveBase,
  testAddStep,
  testRemoveStep,
  testCycleRemoval,
  testAlternativeSupport,
  testEmptyBase,
  testSelfLoop,
  runTests,
}
/*  Not a pure module */
