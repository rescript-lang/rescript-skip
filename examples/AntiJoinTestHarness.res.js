// Generated by ReScript, PLEASE EDIT WITH CARE

import * as SkipruntimeCore from "../bindings/SkipruntimeCore.res.js";
import * as SkipruntimeServer from "../bindings/SkipruntimeServer.res.js";
import * as Helpers from "@skipruntime/helpers";
import * as AntiJoinTestServiceJs from "./AntiJoinTestService.js";

let service = AntiJoinTestServiceJs.service;

let defaultOpts = {
  streaming_port: 18093,
  control_port: 18092,
  platform: "wasm",
  no_cors: undefined
};

function start(opts) {
  return SkipruntimeServer.Natural.runService(service, opts);
}

function stop(server) {
  return SkipruntimeServer.Natural.close(server);
}

let Server = {
  service: service,
  defaultOpts: defaultOpts,
  start: start,
  stop: stop
};

let localhost = "127.0.0.1";

function makeBroker(opts) {
  return new Helpers.SkipServiceBroker({
    host: localhost,
    streaming_port: opts.streaming_port,
    control_port: opts.control_port,
    secured: undefined
  }, undefined);
}

function addBlocker(broker, key, reason) {
  let data = Object.fromEntries([[
      "reason",
      reason
    ]]);
  return broker.update("right", [[
      key,
      [data]
    ]]);
}

function removeBlocker(broker, key) {
  return broker.update("right", [[
      key,
      []
    ]]);
}

async function getStreamUrl(opts, broker, resource) {
  let uuid = await broker.getStreamUUID(resource, undefined);
  return `http://` + localhost + `:` + opts.streaming_port.toString() + `/v1/streams/` + uuid;
}

let Client = {
  localhost: localhost,
  makeBroker: makeBroker,
  addBlocker: addBlocker,
  removeBlocker: removeBlocker,
  getStreamUrl: getStreamUrl
};

let sseUpdates = {
  contents: []
};

let updateCount = {
  contents: 0
};

function handleSSE(data) {
  updateCount.contents = updateCount.contents + 1 | 0;
  let dataStr = JSON.stringify(data);
  sseUpdates.contents.push(dataStr);
  console.log(`[SSE #` + updateCount.contents.toString() + `] ` + dataStr);
}

function delay(ms) {
  return new Promise((resolve, _reject) => {
    setTimeout(() => resolve(), ms);
  });
}

async function run() {
  console.log("===========================================");
  console.log("Anti-Join Test: Does Skip Track Negative Dependencies?");
  console.log("===========================================");
  console.log("");
  console.log("Question: Can we express anti-join (set difference) via map-with-lookup?");
  console.log("");
  console.log("Test: left={a,b}, right={}. Mapper outputs left entries NOT in right.");
  console.log("When we add 'a' to right, does 'a' disappear from the anti-join output?");
  console.log("");
  let server = await start(defaultOpts);
  console.log("Server started on ports 18092/18093");
  let broker = makeBroker(defaultOpts);
  let antiJoinUrl = await getStreamUrl(defaultOpts, broker, "antiJoin");
  console.log(`Subscribing to antiJoin resource...`);
  let subscription = SkipruntimeCore.subscribeSSE(antiJoinUrl, handleSSE);
  await delay(500);
  console.log("");
  console.log("--- Phase 1: Initial State ---");
  console.log("  left = {a: value_a, b: value_b}");
  console.log("  right = {} (empty)");
  console.log("  Expected antiJoin: {a, b} (nothing blocked)");
  console.log("");
  await delay(300);
  console.log("--- Phase 2: Add blocker for 'a' ---");
  console.log("  Adding right[a] = {reason: 'blocked'}");
  console.log("");
  console.log("  ⚡ CRITICAL TEST: Does Skip detect that antiJoin[a] should update?");
  console.log("  If yes → Skip tracks negative dependencies → anti-join IS expressible!");
  console.log("  If no → Skip doesn't track missing-key lookups → anti-join needs new operator");
  console.log("");
  await addBlocker(broker, "a", "blocked");
  await delay(500);
  console.log("");
  console.log("--- Phase 3: Remove blocker for 'a' ---");
  console.log("  Removing right[a]");
  console.log("  Expected: antiJoin should have {a, b} again");
  console.log("");
  await removeBlocker(broker, "a");
  await delay(500);
  console.log("");
  console.log("===========================================");
  console.log("RESULTS");
  console.log("===========================================");
  console.log(`Total SSE updates received: ` + updateCount.contents.toString());
  console.log("");
  if (updateCount.contents >= 3) {
    console.log("✅ PASS: Skip DOES track negative dependencies!");
    console.log("   Anti-join IS expressible via map-with-lookup.");
    console.log("   The paper's claim needs revision.");
  } else if (updateCount.contents === 1) {
    console.log("❌ FAIL: Skip does NOT track negative dependencies.");
    console.log("   Only received initial state, no updates when right changed.");
    console.log("   Anti-join requires a new operator (filterNotMatchingOn).");
  } else {
    console.log("⚠️  INCONCLUSIVE: Received ${updateCount.contents->Int.toString} updates.");
    console.log("   Check the SSE output above to understand what happened.");
  }
  console.log("");
  subscription.close();
  await SkipruntimeServer.Natural.close(server);
  console.log("Server stopped.");
  console.log("");
  console.log("Test complete!");
}

run();

export {
  Server,
  Client,
  sseUpdates,
  updateCount,
  handleSSE,
  delay,
  run,
}
/* service Not a pure module */
