// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as ClientReducer from "../bindings/ClientReducer.res.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as SkipruntimeCore from "../bindings/SkipruntimeCore.res.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";
import * as Primitive_string from "@rescript/runtime/lib/es6/Primitive_string.js";
import * as SkipruntimeServer from "../bindings/SkipruntimeServer.res.js";
import * as SkipruntimeFixpoint from "../bindings/SkipruntimeFixpoint.res.js";
import * as Helpers from "@skipruntime/helpers";
import * as ReanalyzeDCEServiceJs from "./ReanalyzeDCEService.js";

let service = ReanalyzeDCEServiceJs.service;

let defaultOpts = {
  streaming_port: 18091,
  control_port: 18090,
  platform: "wasm",
  no_cors: undefined
};

function start(opts) {
  return SkipruntimeServer.Natural.runService(service, opts);
}

function stop(server) {
  return SkipruntimeServer.Natural.close(server);
}

let Server = {
  service: service,
  defaultOpts: defaultOpts,
  start: start,
  stop: stop
};

let localhost = "127.0.0.1";

function makeBroker(opts) {
  return new Helpers.SkipServiceBroker({
    host: localhost,
    streaming_port: opts.streaming_port,
    control_port: opts.control_port,
    secured: undefined
  }, undefined);
}

function updateFile(broker, filename, data) {
  let jsonData = Object.fromEntries([
    [
      "decls",
      data.decls.map(d => (d))
    ],
    [
      "refs",
      data.refs.map(param => ([
        param[0],
        param[1]
      ]))
    ],
    [
      "annotations",
      data.annotations.map(param => ([
        param[0],
        param[1]
      ]))
    ],
    [
      "optArgCalls",
      data.optArgCalls.map(param => ([
        param[0],
        param[1],
        param[2].map(a => (a))
      ]))
    ]
  ]);
  return broker.update("files", [[
      filename,
      [jsonData]
    ]]);
}

function deleteFile(broker, filename) {
  return broker.update("files", [[
      filename,
      []
    ]]);
}

async function getStreamUrl(opts, broker, resource) {
  let uuid = await broker.getStreamUUID(resource, undefined);
  return `http://` + localhost + `:` + opts.streaming_port.toString() + `/v1/streams/` + uuid;
}

let Client = {
  localhost: localhost,
  makeBroker: makeBroker,
  updateFile: updateFile,
  deleteFile: deleteFile,
  getStreamUrl: getStreamUrl
};

let declsReducer = ClientReducer.SetReducer.make();

let refsReducer = ClientReducer.SetReducer.make();

let annotReducer = ClientReducer.MapReducer.make();

let optArgCallsReducer = ClientReducer.ArrayReducer.make();

let state = {
  fixpoint: SkipruntimeFixpoint.make([]),
  subscription: undefined,
  currentBase: new Set(),
  currentStep: new Set(),
  usedArgsWithProvenance: new Map(),
  optArgCallsByCaller: new Map()
};

let sseUpdateCount = {
  contents: 0
};

let updateCount = {
  contents: 0
};

let totalUpdateTimeMs = {
  contents: 0.0
};

let isInitialized = {
  contents: false
};

function edgeKey(source, target) {
  return source + `→` + target;
}

function parseEdge(key) {
  let match = key.split("→");
  if (match.length !== 2) {
    return;
  }
  let source = match[0];
  let target = match[1];
  return [
    source,
    target
  ];
}

function getAllDecls() {
  return ClientReducer.SetReducer.currentSet(declsReducer);
}

function getAllRefs() {
  return ClientReducer.SetReducer.currentSet(refsReducer);
}

function getAllAnnotations() {
  return ClientReducer.MapReducer.currentMap(annotReducer);
}

function getAllOptArgCalls() {
  return ClientReducer.ArrayReducer.currentArray(optArgCallsReducer);
}

function getRefsByTarget() {
  let result = new Map();
  ClientReducer.SetReducer.currentSet(refsReducer).forEach(param => {
    let source = param[1];
    let target = param[0];
    let sources = result.get(target);
    if (sources !== undefined) {
      sources.add(source);
      return;
    }
    let sources$1 = new Set();
    sources$1.add(source);
    result.set(target, sources$1);
  });
  return result;
}

function rebuildOptArgCallsByCaller() {
  state.optArgCallsByCaller = new Map();
  ClientReducer.ArrayReducer.currentArray(optArgCallsReducer).forEach(call => {
    let existing = Stdlib_Option.getOr(state.optArgCallsByCaller.get(call.caller), []);
    state.optArgCallsByCaller.set(call.caller, existing.concat([call]));
  });
}

function addCallerToUsedArgs(caller) {
  let calls = state.optArgCallsByCaller.get(caller);
  if (calls !== undefined) {
    calls.forEach(param => {
      let fn = param.fn;
      let c = param.caller;
      param.passed.forEach(arg => {
        let m = state.usedArgsWithProvenance.get(fn);
        let fnMap;
        if (m !== undefined) {
          fnMap = m;
        } else {
          let m$1 = new Map();
          state.usedArgsWithProvenance.set(fn, m$1);
          fnMap = m$1;
        }
        let s = fnMap.get(arg);
        let callers;
        if (s !== undefined) {
          callers = s;
        } else {
          let s$1 = new Set();
          fnMap.set(arg, s$1);
          callers = s$1;
        }
        callers.add(c);
      });
    });
    return;
  }
}

function removeCallerFromUsedArgs(caller) {
  let calls = state.optArgCallsByCaller.get(caller);
  if (calls !== undefined) {
    calls.forEach(param => {
      let fn = param.fn;
      let c = param.caller;
      param.passed.forEach(arg => {
        let fnMap = state.usedArgsWithProvenance.get(fn);
        if (fnMap === undefined) {
          return;
        }
        let callers = fnMap.get(arg);
        if (callers !== undefined) {
          callers.delete(c);
          return;
        }
      });
    });
    return;
  }
}

function getUsedArgs(fn) {
  let result = new Set();
  let fnMap = state.usedArgsWithProvenance.get(fn);
  if (fnMap !== undefined) {
    fnMap.entries().forEach(entry => {
      if (entry[1].size > 0) {
        result.add(entry[0]);
        return;
      }
    });
  }
  return result;
}

function computeDesiredBase() {
  let base = new Set();
  let allAnnotations = ClientReducer.MapReducer.currentMap(annotReducer);
  let allDecls = ClientReducer.SetReducer.currentSet(declsReducer);
  let refsByTarget = getRefsByTarget();
  allAnnotations.entries().forEach(entry => {
    if (entry[1] === "live") {
      base.add(entry[0]);
      return;
    }
  });
  refsByTarget.entries().forEach(entry => {
    let hasExternalRef = {
      contents: false
    };
    entry[1].forEach(src => {
      if (!allDecls.has(src)) {
        hasExternalRef.contents = true;
        return;
      }
    });
    if (hasExternalRef.contents) {
      base.add(entry[0]);
      return;
    }
  });
  return base;
}

function computeDesiredStep() {
  let step = new Set();
  let allAnnotations = ClientReducer.MapReducer.currentMap(annotReducer);
  let refsByTarget = getRefsByTarget();
  refsByTarget.entries().forEach(entry => {
    let target = entry[0];
    entry[1].forEach(source => {
      let isBlocked = Primitive_object.equal(allAnnotations.get(source), "dead");
      if (!isBlocked) {
        step.add(edgeKey(source, target));
        return;
      }
    });
  });
  return step;
}

function setDiff(a, b) {
  let result = [];
  a.forEach(x => {
    if (!b.has(x)) {
      result.push(x);
      return;
    }
  });
  return result;
}

function updateFixpointIncremental() {
  updateCount.contents = updateCount.contents + 1 | 0;
  let startTime = Date.now();
  rebuildOptArgCallsByCaller();
  let desiredBase = computeDesiredBase();
  let desiredStep = computeDesiredStep();
  let addedToBase = setDiff(desiredBase, state.currentBase);
  let removedFromBase = setDiff(state.currentBase, desiredBase);
  let addedStepKeys = setDiff(desiredStep, state.currentStep);
  let removedStepKeys = setDiff(state.currentStep, desiredStep);
  let addedToStep = Stdlib_Array.filterMap(addedStepKeys, parseEdge);
  let removedToStep = Stdlib_Array.filterMap(removedStepKeys, parseEdge);
  let changes = SkipruntimeFixpoint.applyChanges(state.fixpoint, addedToBase, removedFromBase, addedToStep, removedToStep);
  changes.removed.forEach(removeCallerFromUsedArgs);
  changes.added.forEach(addCallerToUsedArgs);
  state.currentBase = desiredBase;
  state.currentStep = desiredStep;
  let endTime = Date.now();
  let durationMs = endTime - startTime;
  totalUpdateTimeMs.contents = totalUpdateTimeMs.contents + durationMs;
  console.log(`    [INCREMENTAL #` + updateCount.contents.toString() + `] ` + durationMs.toString() + `ms - ` + (`Δbase: +` + addedToBase.length.toString() + `/-` + removedFromBase.length.toString() + `, `) + (`Δstep: +` + addedToStep.length.toString() + `/-` + removedToStep.length.toString() + `, `) + (`Δfixpoint: +` + changes.added.length.toString() + `/-` + changes.removed.length.toString()));
}

function initializeFixpoint() {
  updateCount.contents = updateCount.contents + 1 | 0;
  let startTime = Date.now();
  rebuildOptArgCallsByCaller();
  let desiredBase = computeDesiredBase();
  let desiredStep = computeDesiredStep();
  state.fixpoint = SkipruntimeFixpoint.make(desiredBase.values().toArray());
  let edgeCount = {
    contents: 0
  };
  desiredStep.forEach(key => {
    let match = parseEdge(key);
    if (match !== undefined) {
      SkipruntimeFixpoint.addToStep(state.fixpoint, match[0], match[1]);
      edgeCount.contents = edgeCount.contents + 1 | 0;
      return;
    }
  });
  state.usedArgsWithProvenance = new Map();
  SkipruntimeFixpoint.current(state.fixpoint).forEach(addCallerToUsedArgs);
  state.currentBase = desiredBase;
  state.currentStep = desiredStep;
  isInitialized.contents = true;
  let endTime = Date.now();
  let durationMs = endTime - startTime;
  totalUpdateTimeMs.contents = totalUpdateTimeMs.contents + durationMs;
  let numSources = declsReducer.contributions.size;
  let numDecls = ClientReducer.SetReducer.currentSet(declsReducer).size;
  console.log(`    [INIT #` + updateCount.contents.toString() + `] ` + durationMs.toString() + `ms - ` + (numSources.toString() + ` files, `) + (numDecls.toString() + ` decls, `) + (desiredBase.size.toString() + ` base, `) + (edgeCount.contents.toString() + ` edges`));
}

function updateFixpoint() {
  if (isInitialized.contents) {
    return updateFixpointIncremental();
  } else {
    return initializeFixpoint();
  }
}

function handleFragmentsData(data) {
  sseUpdateCount.contents = sseUpdateCount.contents + 1 | 0;
  let dataStr = JSON.stringify(data);
  console.log(`[SSE #` + sseUpdateCount.contents.toString() + `] fragments: ` + dataStr.length.toString() + ` bytes`);
  if (!Array.isArray(data)) {
    return;
  }
  console.log(`  → ` + data.length.toString() + ` fragment updates`);
  data.forEach(entry => {
    if (!Array.isArray(entry)) {
      return;
    }
    if (entry.length !== 2) {
      return;
    }
    let match = entry[0];
    if (!Array.isArray(match)) {
      return;
    }
    if (match.length !== 2) {
      return;
    }
    let filename = match[0];
    if (typeof filename !== "string") {
      return;
    }
    let fragmentType = match[1];
    if (typeof fragmentType !== "string") {
      return;
    }
    let values = entry[1];
    if (!Array.isArray(values)) {
      return;
    }
    console.log(`  → file="` + filename + `", fragment="` + fragmentType + `"`);
    let match$1 = values[0];
    switch (fragmentType) {
      case "annotations" :
        let newAnnots = new Map();
        if (Array.isArray(match$1)) {
          console.log(`    → ` + match$1.length.toString() + ` annotations`);
          match$1.forEach(a => {
            if (!Array.isArray(a)) {
              return;
            }
            if (a.length !== 2) {
              return;
            }
            let pos = a[0];
            if (typeof pos !== "string") {
              return;
            }
            let annot = a[1];
            if (typeof annot !== "string") {
              return;
            }
            newAnnots.set(pos, annot);
          });
        } else {
          console.log(`    → DELETED`);
        }
        let delta = ClientReducer.MapReducer.setContribution(annotReducer, filename, newAnnots);
        if (delta.added.length !== 0 || delta.removed.length !== 0) {
          console.log(`    Δagg: +` + delta.added.length.toString() + `/-` + delta.removed.length.toString());
          return;
        } else {
          return;
        }
      case "decls" :
        let newDecls;
        if (match$1 !== undefined) {
          if (Array.isArray(match$1)) {
            console.log(`    → ` + match$1.length.toString() + ` decls`);
            newDecls = Stdlib_Array.filterMap(match$1, d => {
              if (typeof d === "string") {
                return d;
              }
            });
          } else {
            console.log(`    → DELETED`);
            newDecls = [];
          }
        } else {
          console.log(`    → DELETED`);
          newDecls = [];
        }
        let delta$1 = ClientReducer.SetReducer.setContributionArray(declsReducer, filename, newDecls);
        if (delta$1.added.length !== 0 || delta$1.removed.length !== 0) {
          console.log(`    Δagg: +` + delta$1.added.length.toString() + `/-` + delta$1.removed.length.toString());
          return;
        } else {
          return;
        }
      case "optArgCalls" :
        let newCalls;
        if (match$1 !== undefined) {
          if (Array.isArray(match$1)) {
            console.log(`    → ` + match$1.length.toString() + ` optArgCalls`);
            newCalls = Stdlib_Array.filterMap(match$1, c => {
              if (!Array.isArray(c)) {
                return;
              }
              if (c.length !== 3) {
                return;
              }
              let caller = c[0];
              if (typeof caller !== "string") {
                return;
              }
              let fn = c[1];
              if (typeof fn !== "string") {
                return;
              }
              let passed = c[2];
              if (!Array.isArray(passed)) {
                return;
              }
              let passedArgs = Stdlib_Array.filterMap(passed, a => {
                if (typeof a === "string") {
                  return a;
                }
              });
              return {
                caller: caller,
                fn: fn,
                passed: passedArgs
              };
            });
          } else {
            console.log(`    → DELETED`);
            newCalls = [];
          }
        } else {
          console.log(`    → DELETED`);
          newCalls = [];
        }
        let delta$2 = ClientReducer.ArrayReducer.setContribution(optArgCallsReducer, filename, newCalls);
        if (delta$2.added.length !== 0 || delta$2.removed.length !== 0) {
          console.log(`    Δagg: +` + delta$2.added.length.toString() + `/-` + delta$2.removed.length.toString());
          return;
        } else {
          return;
        }
      case "refs" :
        let newRefs;
        if (match$1 !== undefined) {
          if (Array.isArray(match$1)) {
            console.log(`    → ` + match$1.length.toString() + ` refs`);
            newRefs = Stdlib_Array.filterMap(match$1, r => {
              if (!Array.isArray(r)) {
                return;
              }
              if (r.length !== 2) {
                return;
              }
              let target = r[0];
              if (typeof target !== "string") {
                return;
              }
              let source = r[1];
              if (typeof source === "string") {
                return [
                  target,
                  source
                ];
              }
            });
          } else {
            console.log(`    → DELETED`);
            newRefs = [];
          }
        } else {
          console.log(`    → DELETED`);
          newRefs = [];
        }
        let delta$3 = ClientReducer.SetReducer.setContributionArray(refsReducer, filename, newRefs);
        if (delta$3.added.length !== 0 || delta$3.removed.length !== 0) {
          console.log(`    Δagg: +` + delta$3.added.length.toString() + `/-` + delta$3.removed.length.toString());
          return;
        } else {
          return;
        }
      default:
        return;
    }
  });
  updateFixpoint();
}

function subscribe(fragmentsUrl) {
  let sub = SkipruntimeCore.subscribeSSE(fragmentsUrl, handleFragmentsData);
  state.subscription = sub;
}

function close() {
  let sub = state.subscription;
  if (sub !== undefined) {
    sub.close();
  }
  state.subscription = undefined;
}

function getLiveSet() {
  return SkipruntimeFixpoint.current(state.fixpoint);
}

function getDeadSet() {
  let live = new Set(SkipruntimeFixpoint.current(state.fixpoint));
  let dead = [];
  ClientReducer.SetReducer.currentSet(declsReducer).forEach(decl => {
    if (!live.has(decl)) {
      dead.push(decl);
      return;
    }
  });
  return dead;
}

function getOptionalArgsReport(fn, declaredArgs) {
  let usedSet = getUsedArgs(fn);
  let used = [];
  let unused = [];
  declaredArgs.forEach(arg => {
    if (usedSet.has(arg)) {
      used.push(arg);
    } else {
      unused.push(arg);
    }
  });
  return {
    used: used,
    unused: unused
  };
}

let ClientDCE = {
  declsReducer: declsReducer,
  refsReducer: refsReducer,
  annotReducer: annotReducer,
  optArgCallsReducer: optArgCallsReducer,
  state: state,
  sseUpdateCount: sseUpdateCount,
  updateCount: updateCount,
  totalUpdateTimeMs: totalUpdateTimeMs,
  isInitialized: isInitialized,
  edgeKey: edgeKey,
  parseEdge: parseEdge,
  getAllDecls: getAllDecls,
  getAllRefs: getAllRefs,
  getAllAnnotations: getAllAnnotations,
  getAllOptArgCalls: getAllOptArgCalls,
  getRefsByTarget: getRefsByTarget,
  rebuildOptArgCallsByCaller: rebuildOptArgCallsByCaller,
  addCallerToUsedArgs: addCallerToUsedArgs,
  removeCallerFromUsedArgs: removeCallerFromUsedArgs,
  getUsedArgs: getUsedArgs,
  computeDesiredBase: computeDesiredBase,
  computeDesiredStep: computeDesiredStep,
  setDiff: setDiff,
  updateFixpointIncremental: updateFixpointIncremental,
  initializeFixpoint: initializeFixpoint,
  updateFixpoint: updateFixpoint,
  handleFragmentsData: handleFragmentsData,
  subscribe: subscribe,
  close: close,
  getLiveSet: getLiveSet,
  getDeadSet: getDeadSet,
  getOptionalArgsReport: getOptionalArgsReport
};

function delay(ms) {
  return new Promise((resolve, _reject) => {
    setTimeout(() => resolve(), ms);
  });
}

function logArray(label, arr) {
  console.log(label + ": [" + arr.toSorted(Primitive_string.compare).join(", ") + "]");
}

async function run() {
  console.log("===========================================");
  console.log("Reanalyze DCE Harness - Dis-aggregation Pattern");
  console.log("===========================================");
  console.log("");
  console.log("Server: Receives complete file data → dis-aggregates into fragments");
  console.log("Client: Receives small deltas → computes liveness locally");
  console.log("");
  console.log("When only annotations change, only the annotations fragment is sent!");
  console.log("");
  let server = await start(defaultOpts);
  console.log("Server started on ports 18090/18091");
  let broker = makeBroker(defaultOpts);
  let fragmentsUrl = await getStreamUrl(defaultOpts, broker, "fragments");
  console.log(`Subscribing to fragments resource via SSE...`);
  subscribe(fragmentsUrl);
  await delay(500);
  console.log("");
  console.log("--- Phase 1: Initial State ---");
  console.log("  main.res: decls=[main, unused_in_main], refs=[[utils,main],[api,main]], @live=main");
  console.log("           optArgCalls: main calls utils(~format)");
  console.log("  utils.res: decls=[utils, helpers, dead_util], refs=[[helpers,utils]]");
  console.log("           (utils has optional args: ~format, ~locale, ~timezone)");
  console.log("  api.res: decls=[api, db, logger], refs=[[db,api],[logger,api]], @dead=api");
  console.log("           optArgCalls: api calls utils(~format, ~locale) - BUT API IS DEAD!");
  console.log("");
  logArray("Live set", SkipruntimeFixpoint.current(state.fixpoint));
  logArray("Dead set", getDeadSet());
  let utilsArgs = getOptionalArgsReport("utils", [
    "~format",
    "~locale",
    "~timezone"
  ]);
  console.log("");
  console.log("Optional args for 'utils' (only from LIVE callers):");
  logArray("  Used args", utilsArgs.used);
  logArray("  Unused args", utilsArgs.unused);
  console.log("  (api's call to utils(~format, ~locale) doesn't count - api is dead!)");
  console.log("");
  console.log("--- Phase 2: Add feature.res (new file) ---");
  console.log("  Sending complete file data in ONE update:");
  console.log("  { decls: [feature], refs: [[dead_util, feature]], annotations: [[feature, live]],");
  console.log("    optArgCalls: feature calls utils(~timezone) }");
  console.log("");
  await updateFile(broker, "feature.res", {
    decls: ["feature"],
    refs: [[
        "dead_util",
        "feature"
      ]],
    annotations: [[
        "feature",
        "live"
      ]],
    optArgCalls: [[
        "feature",
        "utils",
        ["~timezone"]
      ]]
  });
  await delay(300);
  logArray("Live set", SkipruntimeFixpoint.current(state.fixpoint));
  logArray("Dead set", getDeadSet());
  let utilsArgs2 = getOptionalArgsReport("utils", [
    "~format",
    "~locale",
    "~timezone"
  ]);
  console.log("Optional args for 'utils':");
  logArray("  Used args", utilsArgs2.used);
  logArray("  Unused args", utilsArgs2.unused);
  console.log("  (feature's call added ~timezone!)");
  console.log("");
  console.log("--- Phase 3: Update api.res (remove @dead annotation) ---");
  console.log("  Sending file with empty annotations:");
  console.log("  { decls: [api, db, logger], refs: [[db,api],[logger,api]], annotations: [],");
  console.log("    optArgCalls: api calls utils(~format, ~locale) }");
  console.log("");
  console.log("  ⚡ EXPECT: Only 'annotations' fragment delta sent!");
  console.log("  ⚡ EXPECT: api becomes LIVE → its optArgCalls now count!");
  console.log("");
  await updateFile(broker, "api.res", {
    decls: [
      "api",
      "db",
      "logger"
    ],
    refs: [
      [
        "db",
        "api"
      ],
      [
        "logger",
        "api"
      ]
    ],
    annotations: [],
    optArgCalls: [[
        "api",
        "utils",
        [
          "~format",
          "~locale"
        ]
      ]]
  });
  await delay(300);
  logArray("Live set", SkipruntimeFixpoint.current(state.fixpoint));
  logArray("Dead set", getDeadSet());
  let utilsArgs3 = getOptionalArgsReport("utils", [
    "~format",
    "~locale",
    "~timezone"
  ]);
  console.log("Optional args for 'utils':");
  logArray("  Used args", utilsArgs3.used);
  logArray("  Unused args", utilsArgs3.unused);
  console.log("  (api became live → ~locale now used!)");
  console.log("");
  console.log("--- Phase 4: Update utils.res (add new_helper decl) ---");
  console.log("  Sending file with new decl:");
  console.log("  { decls: [utils, helpers, dead_util, new_helper], refs: [[helpers,utils]], annotations: [],");
  console.log("    optArgCalls: [] }");
  console.log("");
  console.log("  ⚡ EXPECT: Only 'decls' fragment delta sent (refs/annotations unchanged)!");
  console.log("");
  await updateFile(broker, "utils.res", {
    decls: [
      "utils",
      "helpers",
      "dead_util",
      "new_helper"
    ],
    refs: [[
        "helpers",
        "utils"
      ]],
    annotations: [],
    optArgCalls: []
  });
  await delay(300);
  logArray("Live set", SkipruntimeFixpoint.current(state.fixpoint));
  logArray("Dead set", getDeadSet());
  console.log("");
  console.log("===========================================");
  console.log("SUMMARY: Fixpoint Update Cost");
  console.log("===========================================");
  console.log(`Total updates: ` + updateCount.contents.toString());
  console.log(`Total update time: ` + totalUpdateTimeMs.contents.toString() + `ms`);
  console.log(`Average per update: ` + (totalUpdateTimeMs.contents / updateCount.contents).toString() + `ms`);
  console.log("");
  console.log("✅ Using incremental updates via SkipruntimeFixpoint.applyChanges()");
  console.log("   Only changed base/step elements are updated!");
  console.log("");
  close();
  await SkipruntimeServer.Natural.close(server);
  console.log("Server stopped.");
  console.log("");
  console.log("Demo complete!");
}

run();

export {
  Server,
  Client,
  ClientDCE,
  delay,
  logArray,
  run,
}
/* service Not a pure module */
