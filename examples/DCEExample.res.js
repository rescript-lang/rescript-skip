// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Primitive_string from "@rescript/runtime/lib/es6/Primitive_string.js";
import * as SkipruntimeFixpoint from "../bindings/SkipruntimeFixpoint.res.js";

function makeDCEService(nodes, roots, edges) {
  let fixpoint = SkipruntimeFixpoint.make(roots);
  edges.forEach(param => {
    let from = param[0];
    param[1].forEach(to_ => {
      SkipruntimeFixpoint.addToStep(fixpoint, from, to_);
    });
  });
  return {
    nodes: nodes,
    fixpoint: fixpoint
  };
}

function getLiveSet(service) {
  return SkipruntimeFixpoint.current(service.fixpoint);
}

function getDeadSet(service) {
  let live = new Set(SkipruntimeFixpoint.current(service.fixpoint));
  return service.nodes.filter(node => !live.has(node));
}

function addRoot(service, root) {
  return SkipruntimeFixpoint.addToBase(service.fixpoint, root);
}

function removeRoot(service, root) {
  return SkipruntimeFixpoint.removeFromBase(service.fixpoint, root);
}

function addEdge(service, from, to_) {
  return SkipruntimeFixpoint.addToStep(service.fixpoint, from, to_);
}

function removeEdge(service, from, to_) {
  return SkipruntimeFixpoint.removeFromStep(service.fixpoint, from, to_);
}

function log(prim) {
  console.log(prim);
}

function logArray(label, arr) {
  console.log(label + ": [" + arr.toSorted(Primitive_string.compare).join(", ") + "]");
}

function logCounts(label, service) {
  let live = SkipruntimeFixpoint.current(service.fixpoint);
  let dead = getDeadSet(service);
  console.log(label, {
    live: live.length,
    dead: dead.length
  });
}

function naiveReachability(roots, edges, nodeCount) {
  let visited = new Set();
  let queue = [];
  roots.forEach(root => {
    if (!visited.has(root)) {
      visited.add(root);
      queue.push(root);
      return;
    }
  });
  let head = 0;
  while (head < queue.length) {
    let current = queue[head];
    head = head + 1 | 0;
    let neighbors = edges.get(current);
    if (neighbors !== undefined) {
      neighbors.forEach(neighbor => {
        if (!visited.has(neighbor)) {
          visited.add(neighbor);
          queue.push(neighbor);
          return;
        }
      });
    }
  };
  let liveCount = visited.size;
  return [
    liveCount,
    nodeCount - liveCount | 0
  ];
}

function demo() {
  console.log("Dead Code Elimination Demo");
  console.log("==========================");
  console.log("");
  let service = makeDCEService([
    "main",
    "utils",
    "helpers",
    "api",
    "db",
    "logger",
    "unused1",
    "unused2"
  ], ["main"], [
    [
      "main",
      [
        "utils",
        "api"
      ]
    ],
    [
      "utils",
      ["helpers"]
    ],
    [
      "api",
      [
        "db",
        "logger"
      ]
    ],
    [
      "unused1",
      ["unused2"]
    ]
  ]);
  console.log("Initial graph:");
  console.log("  main → utils, api");
  console.log("  utils → helpers");
  console.log("  api → db, logger");
  console.log("  unused1 → unused2");
  console.log("");
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  logArray("Dead set", getDeadSet(service));
  console.log("");
  console.log("--- Add 'unused1' as a new root ---");
  let changes1 = SkipruntimeFixpoint.addToBase(service.fixpoint, "unused1");
  logArray("Added", changes1.added);
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  logArray("Dead set", getDeadSet(service));
  console.log("");
  console.log("--- Remove 'main' root ---");
  let changes2 = SkipruntimeFixpoint.removeFromBase(service.fixpoint, "main");
  logArray("Removed", changes2.removed);
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  logArray("Dead set", getDeadSet(service));
  console.log("");
  console.log("--- Add 'main' root back ---");
  let changes3 = SkipruntimeFixpoint.addToBase(service.fixpoint, "main");
  logArray("Added", changes3.added);
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  console.log("");
  console.log("--- Remove edge main → api ---");
  let changes4 = removeEdge(service, "main", "api");
  logArray("Removed", changes4.removed);
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  console.log("");
  console.log("--- Add edge helpers → main (creates cycle) ---");
  addEdge(service, "helpers", "main");
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  console.log("");
  console.log("--- Remove edge main → utils ---");
  console.log("    (helpers → main cycle should die because no wf-deriver)");
  let changes6 = removeEdge(service, "main", "utils");
  logArray("Removed", changes6.removed);
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  console.log("");
  console.log("Demo complete!");
}

function alternativePathDemo() {
  console.log("");
  console.log("Alternative Path Demo");
  console.log("=====================");
  console.log("(This tests the edge case that required algorithm revision)");
  console.log("");
  let service = makeDCEService([
    "main",
    "api",
    "backup",
    "db"
  ], ["main"], [
    [
      "main",
      [
        "api",
        "backup"
      ]
    ],
    [
      "api",
      ["db"]
    ],
    [
      "backup",
      ["db"]
    ]
  ]);
  console.log("Graph with redundant paths to db:");
  console.log("  main → api → db");
  console.log("  main → backup → db");
  console.log("");
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  logArray("Dead set", getDeadSet(service));
  console.log("");
  console.log("--- Remove edge main → api ---");
  console.log("    (db should survive via backup path)");
  let changes = removeEdge(service, "main", "api");
  logArray("Removed", changes.removed);
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  console.log("");
  let dbIsLive = SkipruntimeFixpoint.current(service.fixpoint).includes("db");
  if (dbIsLive) {
    console.log("✓ CORRECT: db survived via alternative path (main → backup → db)");
  } else {
    console.log("✗ BUG: db was incorrectly removed!");
  }
  console.log("");
  console.log("--- Remove edge backup → db ---");
  console.log("    (now db has no path from main)");
  let changes2 = removeEdge(service, "backup", "db");
  logArray("Removed", changes2.removed);
  logArray("Live set", SkipruntimeFixpoint.current(service.fixpoint));
  console.log("");
  console.log("Alternative path demo complete!");
}

function buildTreeGraph(branching, height) {
  let edges = new Map();
  let edgesArray = [];
  let nodeNames = [];
  let nodeId = {
    contents: 0
  };
  let currentLevel = [0];
  nodeNames.push("node-0");
  nodeId.contents = 1;
  for (let _level = 1; _level <= height; ++_level) {
    let nextLevel = [];
    currentLevel.forEach(parent => {
      let children = [];
      for (let _child = 1; _child <= branching; ++_child) {
        let childId = nodeId.contents;
        nodeId.contents = nodeId.contents + 1 | 0;
        children.push(childId);
        nextLevel.push(childId);
        nodeNames.push("node-" + childId.toString());
      }
      edges.set(parent, children);
      let childNames = children.map(c => "node-" + c.toString());
      edgesArray.push([
        "node-" + parent.toString(),
        childNames
      ]);
    });
    currentLevel = nextLevel;
  }
  return [
    nodeNames,
    edges,
    edgesArray,
    height
  ];
}

function countSubtree(edges, root) {
  let count = 0;
  let queue = [root];
  let head = 0;
  while (head < queue.length) {
    let current = queue[head];
    head = head + 1 | 0;
    count = count + 1 | 0;
    let children = edges.get(current);
    if (children !== undefined) {
      children.forEach(c => {
        queue.push(c);
      });
    }
  };
  return count;
}

function stressBenchmark(nodeNames, naiveEdges, edgesArray, editCount, cutParent, cutChild, label) {
  let nodeCount = nodeNames.length;
  console.log("");
  console.log("=================================================================");
  console.log(label);
  console.log("=================================================================");
  let subtreeSize = countSubtree(naiveEdges, cutChild);
  console.log("Subtree being cut", {
    parent: cutParent,
    child: cutChild,
    subtree_size: subtreeSize
  });
  console.log("");
  console.log("Setting up incremental service (not timed)...");
  let service = makeDCEService(nodeNames, ["node-0"], edgesArray);
  let fromNode = "node-" + cutParent.toString();
  let toNode = "node-" + cutChild.toString();
  let originalChildren = Stdlib_Option.getOr(naiveEdges.get(cutParent), []);
  let incInitLive = SkipruntimeFixpoint.current(service.fixpoint).length;
  console.log("Initial", {
    live: incInitLive,
    dead: nodeCount - incInitLive | 0
  });
  console.log("");
  let prim = "--- Incremental: " + editCount.toString() + " edits ---";
  console.log(prim);
  let incTotalMs = 0.0;
  for (let edit = 1; edit <= editCount; ++edit) {
    let startMs = Date.now();
    if (edit % 2 === 1) {
      removeEdge(service, fromNode, toNode);
    } else {
      addEdge(service, fromNode, toNode);
    }
    let elapsedMs = Date.now() - startMs;
    incTotalMs = incTotalMs + elapsedMs;
    if (edit <= 4) {
      let live = SkipruntimeFixpoint.current(service.fixpoint).length;
      let dead = nodeCount - live | 0;
      let action = edit % 2 === 1 ? "remove" : "add";
      console.log("  Edit " + edit.toString() + " (" + action + ")", {
        ms: elapsedMs,
        live: live,
        dead: dead
      });
    } else if (edit === 5) {
      console.log("  ...");
    }
  }
  let incFinalLive = SkipruntimeFixpoint.current(service.fixpoint).length;
  let incFinalDead = nodeCount - incFinalLive | 0;
  console.log("  Final state", {
    live: incFinalLive,
    dead: incFinalDead
  });
  console.log("");
  let prim$1 = "--- Naive BFS: " + editCount.toString() + " edits with full recompute ---";
  console.log(prim$1);
  let naiveTotalMs = 0.0;
  let naiveRoots = [0];
  let naiveLive = 0;
  let naiveDead = 0;
  for (let edit$1 = 1; edit$1 <= editCount; ++edit$1) {
    if (edit$1 % 2 === 1) {
      let withoutChild = originalChildren.filter(c => c !== cutChild);
      naiveEdges.set(cutParent, withoutChild);
    } else {
      naiveEdges.set(cutParent, originalChildren);
    }
    let startMs$1 = Date.now();
    let match = naiveReachability(naiveRoots, naiveEdges, nodeCount);
    let dead$1 = match[1];
    let live$1 = match[0];
    let elapsedMs$1 = Date.now() - startMs$1;
    naiveTotalMs = naiveTotalMs + elapsedMs$1;
    naiveLive = live$1;
    naiveDead = dead$1;
    if (edit$1 <= 4) {
      let action$1 = edit$1 % 2 === 1 ? "remove" : "add";
      console.log("  Edit " + edit$1.toString() + " (" + action$1 + ")", {
        ms: elapsedMs$1,
        live: live$1,
        dead: dead$1
      });
    } else if (edit$1 === 5) {
      console.log("  ...");
    }
  }
  console.log("  Final state", {
    live: naiveLive,
    dead: naiveDead
  });
  naiveEdges.set(cutParent, originalChildren);
  console.log("");
  let speedup = naiveTotalMs / incTotalMs;
  console.log("TOTAL", {
    incremental_ms: incTotalMs,
    naive_ms: naiveTotalMs,
    speedup: speedup
  });
  if (speedup > 1.0) {
    let prim$2 = "✓ Incremental is " + speedup.toFixed(1) + "x faster";
    console.log(prim$2);
    return;
  }
  let prim$3 = "✗ Naive is " + (1.0 / speedup).toFixed(1) + "x faster";
  console.log(prim$3);
}

function runBenchmarks() {
  console.log("");
  console.log("DCE Benchmark: Incremental vs Naive BFS Reachability");
  console.log("=====================================================");
  console.log("");
  console.log("Graph: Tree with branching factor 10, height 5");
  console.log("  - This models a realistic call graph");
  console.log("  - Height 5 = max call chain depth of 5");
  console.log("");
  let match = buildTreeGraph(10, 5);
  let edgesArray = match[2];
  let naiveEdges = match[1];
  let nodeNames = match[0];
  let nodeCount = nodeNames.length;
  console.log("Tree structure", {
    nodes: nodeCount,
    branching: 10,
    height: match[3]
  });
  console.log("");
  console.log("Complexity:");
  console.log("- Incremental: O(affected subtree size)");
  console.log("- Naive BFS: O(total nodes) every time");
  console.log("");
  stressBenchmark(nodeNames, naiveEdges, edgesArray, 100, 1111, 11111, "SCENARIO 1: Cut LEAF edge (subtree = 1 node)");
  stressBenchmark(nodeNames, naiveEdges, edgesArray, 100, 11, 111, "SCENARIO 2: Cut MID-LEVEL edge (subtree = 111 nodes)");
  stressBenchmark(nodeNames, naiveEdges, edgesArray, 10, 0, 1, "SCENARIO 3: Cut NEAR-ROOT edge (subtree = 11111 nodes)");
  console.log("");
  console.log("=================================================================");
  console.log("CONCLUSION");
  console.log("=================================================================");
  console.log("Incremental wins when editing deep in the tree (small subtrees).");
  console.log("This is the common case: most code edits affect leaf functions.");
  console.log("");
}

demo();

alternativePathDemo();

runBenchmarks();

export {
  makeDCEService,
  getLiveSet,
  getDeadSet,
  addRoot,
  removeRoot,
  addEdge,
  removeEdge,
  log,
  logArray,
  logCounts,
  naiveReachability,
  demo,
  alternativePathDemo,
  buildTreeGraph,
  countSubtree,
  stressBenchmark,
  runBenchmarks,
}
/*  Not a pure module */
