// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Primitive_int from "@rescript/runtime/lib/es6/Primitive_int.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Primitive_object from "@rescript/runtime/lib/es6/Primitive_object.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function make() {
  return {
    contributions: new Map(),
    counts: new Map(),
    current: new Set()
  };
}

function setContribution(reducer, source, values) {
  let oldValues = Stdlib_Option.getOr(reducer.contributions.get(source), new Set());
  let sourceAdded = [];
  let sourceRemoved = [];
  values.forEach(v => {
    if (!oldValues.has(v)) {
      sourceAdded.push(v);
      return;
    }
  });
  oldValues.forEach(v => {
    if (!values.has(v)) {
      sourceRemoved.push(v);
      return;
    }
  });
  if (values.size === 0) {
    reducer.contributions.delete(source);
  } else {
    reducer.contributions.set(source, values);
  }
  let aggregateAdded = [];
  let aggregateRemoved = [];
  sourceAdded.forEach(v => {
    let oldCount = Stdlib_Option.getOr(reducer.counts.get(v), 0);
    let newCount = oldCount + 1 | 0;
    reducer.counts.set(v, newCount);
    if (oldCount === 0) {
      reducer.current.add(v);
      aggregateAdded.push(v);
      return;
    }
  });
  sourceRemoved.forEach(v => {
    let oldCount = Stdlib_Option.getOr(reducer.counts.get(v), 0);
    let newCount = Primitive_int.max(0, oldCount - 1 | 0);
    if (newCount === 0) {
      reducer.counts.delete(v);
      reducer.current.delete(v);
      aggregateRemoved.push(v);
    } else {
      reducer.counts.set(v, newCount);
    }
  });
  return {
    added: aggregateAdded,
    removed: aggregateRemoved
  };
}

function setContributionArray(reducer, source, values) {
  return setContribution(reducer, source, new Set(values));
}

function deleteSource(reducer, source) {
  return setContribution(reducer, source, new Set());
}

function currentArray(reducer) {
  return reducer.current.values().toArray();
}

function currentSet(reducer) {
  return reducer.current;
}

let SetReducer = {
  make: make,
  setContribution: setContribution,
  setContributionArray: setContributionArray,
  deleteSource: deleteSource,
  currentArray: currentArray,
  currentSet: currentSet
};

function make$1() {
  return {
    contributions: new Map(),
    provenance: new Map(),
    current: new Map()
  };
}

function setContribution$1(reducer, source, values) {
  let oldMap = Stdlib_Option.getOr(reducer.contributions.get(source), new Map());
  let aggregateAdded = [];
  let aggregateRemoved = [];
  oldMap.entries().forEach(entry => {
    let key = entry[0];
    let sources = reducer.provenance.get(key);
    if (sources === undefined) {
      return;
    }
    let newSources = sources.filter(param => param[0] !== source);
    if (newSources.length === 0) {
      reducer.provenance.delete(key);
      reducer.current.delete(key);
      aggregateRemoved.push(key);
      return;
    }
    reducer.provenance.set(key, newSources);
    let match = Stdlib_Option.getOrThrow(newSources[newSources.length - 1 | 0], undefined);
    let lastValue = match[1];
    let oldValue = reducer.current.get(key);
    reducer.current.set(key, lastValue);
    if (Primitive_object.notequal(oldValue, Primitive_option.some(lastValue))) {
      aggregateAdded.push([
        key,
        lastValue
      ]);
      return;
    }
  });
  values.entries().forEach(entry => {
    let value = entry[1];
    let key = entry[0];
    let sources = Stdlib_Option.getOr(reducer.provenance.get(key), []);
    let newSources = sources.concat([[
        source,
        value
      ]]);
    reducer.provenance.set(key, newSources);
    let oldValue = reducer.current.get(key);
    reducer.current.set(key, value);
    if (Primitive_object.notequal(oldValue, Primitive_option.some(value))) {
      aggregateAdded.push([
        key,
        value
      ]);
      return;
    }
  });
  if (values.size === 0) {
    reducer.contributions.delete(source);
  } else {
    reducer.contributions.set(source, values);
  }
  return {
    added: aggregateAdded,
    removed: aggregateRemoved
  };
}

function deleteSource$1(reducer, source) {
  return setContribution$1(reducer, source, new Map());
}

function currentMap(reducer) {
  return reducer.current;
}

function get(reducer, key) {
  return reducer.current.get(key);
}

let MapReducer = {
  make: make$1,
  setContribution: setContribution$1,
  deleteSource: deleteSource$1,
  currentMap: currentMap,
  get: get
};

function make$2() {
  return {
    contributions: new Map(),
    current: []
  };
}

function recompute(reducer) {
  let result = [];
  reducer.contributions.values().forEach(arr => {
    arr.forEach(v => {
      result.push(v);
    });
  });
  reducer.current = result;
}

function setContribution$2(reducer, source, values) {
  let oldValues = Stdlib_Option.getOr(reducer.contributions.get(source), []);
  if (values.length === 0) {
    reducer.contributions.delete(source);
  } else {
    reducer.contributions.set(source, values);
  }
  recompute(reducer);
  return {
    added: values,
    removed: oldValues
  };
}

function deleteSource$2(reducer, source) {
  return setContribution$2(reducer, source, []);
}

function currentArray$1(reducer) {
  return reducer.current;
}

let ArrayReducer = {
  make: make$2,
  recompute: recompute,
  setContribution: setContribution$2,
  deleteSource: deleteSource$2,
  currentArray: currentArray$1
};

export {
  SetReducer,
  MapReducer,
  ArrayReducer,
}
/* No side effect */
