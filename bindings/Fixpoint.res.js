// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";
import * as Belt_SetString from "@rescript/runtime/lib/es6/Belt_SetString.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

let emptyDelta_addedToBase = [];

let emptyDelta_removedFromBase = [];

let emptyDelta_addedToStep = [];

let emptyDelta_removedFromStep = [];

let emptyDelta = {
  addedToBase: emptyDelta_addedToBase,
  removedFromBase: emptyDelta_removedFromBase,
  addedToStep: emptyDelta_addedToStep,
  removedFromStep: emptyDelta_removedFromStep
};

let emptyChanges_added = [];

let emptyChanges_removed = [];

let emptyChanges = {
  added: emptyChanges_added,
  removed: emptyChanges_removed
};

function addToInvIndex(state, source, target) {
  let existing = Belt_MapString.getWithDefault(state.invIndex, target, undefined);
  state.invIndex = Belt_MapString.set(state.invIndex, target, Belt_SetString.add(existing, source));
}

function getStepInv(state, x) {
  return Belt_MapString.getWithDefault(state.invIndex, x, undefined);
}

function expand(state, frontier) {
  let added = {
    contents: []
  };
  let currentFrontier = frontier;
  let r = {
    contents: 0
  };
  while (!Belt_SetString.isEmpty(currentFrontier)) {
    Belt_SetString.forEach(currentFrontier, x => {
      if (!Belt_SetString.has(state.current, x)) {
        state.current = Belt_SetString.add(state.current, x);
        state.rank = Belt_MapString.set(state.rank, x, r.contents);
        added.contents = added.contents.concat([x]);
        return;
      }
    });
    let nextFrontier = {
      contents: undefined
    };
    Belt_SetString.forEach(currentFrontier, x => {
      let successors = state.config.stepFwd(x);
      successors.forEach(y => {
        addToInvIndex(state, x, y);
        if (!Belt_SetString.has(state.current, y)) {
          nextFrontier.contents = Belt_SetString.add(nextFrontier.contents, y);
          return;
        }
      });
    });
    currentFrontier = nextFrontier.contents;
    r.contents = r.contents + 1 | 0;
  };
  return added.contents;
}

function hasWellFoundedDeriver(state, x, dying) {
  let xRank = Belt_MapString.get(state.rank, x);
  if (xRank === undefined) {
    return false;
  }
  let derivers = getStepInv(state, x);
  return Belt_SetString.some(derivers, y => {
    let inCurrent = Belt_SetString.has(state.current, y);
    let notDying = !Belt_SetString.has(dying, y);
    let yRank = Belt_MapString.get(state.rank, y);
    if (yRank !== undefined && inCurrent && notDying) {
      return yRank < xRank;
    } else {
      return false;
    }
  });
}

function contract(state, worklist) {
  let dying = {
    contents: undefined
  };
  let currentWorklist = {
    contents: worklist
  };
  while (!Belt_SetString.isEmpty(currentWorklist.contents)) {
    let v = Belt_SetString.minimum(currentWorklist.contents);
    let x = v !== undefined ? v : "";
    currentWorklist.contents = Belt_SetString.remove(currentWorklist.contents, x);
    if (!(Belt_SetString.has(dying.contents, x) || Belt_SetString.has(state.base, x))) {
      let hasSupport = hasWellFoundedDeriver(state, x, dying.contents);
      if (!hasSupport) {
        dying.contents = Belt_SetString.add(dying.contents, x);
        let successors = state.config.stepFwd(x);
        successors.forEach(z => {
          if (Belt_SetString.has(state.current, z) && !Belt_SetString.has(dying.contents, z)) {
            currentWorklist.contents = Belt_SetString.add(currentWorklist.contents, z);
            return;
          }
        });
      }
    }
  };
  Belt_SetString.forEach(dying.contents, x => {
    state.current = Belt_SetString.remove(state.current, x);
    state.rank = Belt_MapString.remove(state.rank, x);
  });
  return Belt_SetString.toArray(dying.contents);
}

function make(config, base) {
  let state = {
    current: undefined,
    rank: undefined,
    invIndex: undefined,
    base: Belt_SetString.fromArray(base),
    config: config
  };
  expand(state, state.base);
  return state;
}

function current(state) {
  return Belt_SetString.toArray(state.current);
}

function rank(state, x) {
  return Belt_MapString.get(state.rank, x);
}

function has(state, x) {
  return Belt_SetString.has(state.current, x);
}

function size(state) {
  return Belt_SetString.size(state.current);
}

function applyDelta(state, delta) {
  let allAdded = [];
  let allRemoved = [];
  delta.removedFromStep.forEach(param => {
    let source = param[0];
    let target = param[1];
    let set = Belt_MapString.get(state.invIndex, target);
    if (set === undefined) {
      return;
    }
    let newSet = Belt_SetString.remove(Primitive_option.valFromOption(set), source);
    if (Belt_SetString.isEmpty(newSet)) {
      state.invIndex = Belt_MapString.remove(state.invIndex, target);
    } else {
      state.invIndex = Belt_MapString.set(state.invIndex, target, newSet);
    }
  });
  let removedBaseSet = Belt_SetString.fromArray(delta.removedFromBase);
  state.base = Belt_SetString.diff(state.base, removedBaseSet);
  let contractionWorklist = {
    contents: undefined
  };
  delta.removedFromBase.forEach(x => {
    if (Belt_SetString.has(state.current, x)) {
      contractionWorklist.contents = Belt_SetString.add(contractionWorklist.contents, x);
      return;
    }
  });
  delta.removedFromStep.forEach(param => {
    let target = param[1];
    if (Belt_SetString.has(state.current, param[0]) && Belt_SetString.has(state.current, target)) {
      contractionWorklist.contents = Belt_SetString.add(contractionWorklist.contents, target);
      return;
    }
  });
  if (!Belt_SetString.isEmpty(contractionWorklist.contents)) {
    let removed = contract(state, contractionWorklist.contents);
    allRemoved = allRemoved.concat(removed);
  }
  delta.addedToStep.forEach(param => addToInvIndex(state, param[0], param[1]));
  let addedBaseSet = Belt_SetString.fromArray(delta.addedToBase);
  state.base = Belt_SetString.union(state.base, addedBaseSet);
  let expansionFrontier = {
    contents: undefined
  };
  delta.addedToBase.forEach(x => {
    if (!Belt_SetString.has(state.current, x)) {
      expansionFrontier.contents = Belt_SetString.add(expansionFrontier.contents, x);
      return;
    }
  });
  delta.addedToStep.forEach(param => {
    let target = param[1];
    if (Belt_SetString.has(state.current, param[0]) && !Belt_SetString.has(state.current, target)) {
      expansionFrontier.contents = Belt_SetString.add(expansionFrontier.contents, target);
      return;
    }
  });
  if (!Belt_SetString.isEmpty(expansionFrontier.contents)) {
    let added = expand(state, expansionFrontier.contents);
    allAdded = allAdded.concat(added);
  }
  return {
    added: allAdded,
    removed: allRemoved
  };
}

function debugInfo(state) {
  return {
    current: Belt_SetString.toArray(state.current),
    ranks: Belt_MapString.toArray(state.rank),
    base: Belt_SetString.toArray(state.base),
    invIndexSize: Belt_MapString.size(state.invIndex)
  };
}

export {
  emptyDelta,
  emptyChanges,
  make,
  current,
  rank,
  has,
  size,
  applyDelta,
  debugInfo,
}
/* No side effect */
