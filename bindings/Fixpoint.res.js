// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib from "@rescript/runtime/lib/es6/Stdlib.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";

function emptyDelta() {
  return {
    addedToBase: [],
    removedFromBase: [],
    addedToStep: [],
    removedFromStep: []
  };
}

function emptyChanges() {
  return {
    added: [],
    removed: []
  };
}

function addToInvIndex(state, source, target) {
  let set = state.invIndex.get(target);
  if (set !== undefined) {
    set.add(source);
    return;
  }
  let set$1 = new Set();
  set$1.add(source);
  state.invIndex.set(target, set$1);
}

function forEachStepInv(state, x, f) {
  let set = state.invIndex.get(x);
  if (set !== undefined) {
    set.forEach(f);
    return;
  }
}

function expand(state, frontier) {
  let added = [];
  let currentFrontier = new Set();
  let nextFrontier = new Set();
  frontier.forEach(x => {
    currentFrontier.add(x);
  });
  let r = {
    contents: 0
  };
  while (currentFrontier.size > 0) {
    currentFrontier.forEach(x => {
      if (!state.current.has(x)) {
        state.current.add(x);
        state.rank.set(x, r.contents);
        added.push(x);
        return;
      }
    });
    nextFrontier.clear();
    currentFrontier.forEach(x => state.config.stepFwdForEach(x, y => {
      addToInvIndex(state, x, y);
      if (!state.current.has(y)) {
        nextFrontier.add(y);
        return;
      }
    }));
    currentFrontier.clear();
    nextFrontier.forEach(x => {
      currentFrontier.add(x);
    });
    r.contents = r.contents + 1 | 0;
  };
  return added;
}

function hasWellFoundedDeriver(state, x, dying) {
  let rx = state.rank.get(x);
  if (rx === undefined) {
    return false;
  }
  let found = {
    contents: false
  };
  forEachStepInv(state, x, y => {
    if (found.contents) {
      return;
    }
    let inCurrent = state.current.has(y);
    let notDying = !dying.has(y);
    let ry = state.rank.get(y);
    if (ry !== undefined && inCurrent && notDying && ry < rx) {
      found.contents = true;
      return;
    }
  });
  return found.contents;
}

function contract(state, worklist) {
  let dying = new Set();
  let currentWorklist = new Set();
  worklist.forEach(x => {
    currentWorklist.add(x);
  });
  while (currentWorklist.size > 0) {
    let v = currentWorklist.values().toArray()[0];
    let x = v !== undefined ? Primitive_option.valFromOption(v) : Stdlib.panic("Worklist should not be empty");
    currentWorklist.delete(x);
    if (!(dying.has(x) || state.base.has(x))) {
      let hasSupport = hasWellFoundedDeriver(state, x, dying);
      if (!hasSupport) {
        dying.add(x);
        state.config.stepFwdForEach(x, z => {
          if (state.current.has(z) && !dying.has(z)) {
            currentWorklist.add(z);
            return;
          }
        });
      }
    }
  };
  let removed = [];
  dying.forEach(x => {
    state.current.delete(x);
    state.rank.delete(x);
    removed.push(x);
  });
  return removed;
}

function make(config, base) {
  let baseSet = new Set(base);
  let state_current = new Set();
  let state_rank = new Map();
  let state_invIndex = new Map();
  let state = {
    current: state_current,
    rank: state_rank,
    invIndex: state_invIndex,
    base: baseSet,
    config: config
  };
  let initialFrontier = new Set(base);
  expand(state, initialFrontier);
  return state;
}

function current(state) {
  return state.current.values().toArray();
}

function rank(state, x) {
  return state.rank.get(x);
}

function has(state, x) {
  return state.current.has(x);
}

function size(state) {
  return state.current.size;
}

function applyDelta(state, delta) {
  let allAdded = [];
  let allRemoved = [];
  delta.removedFromStep.forEach(param => {
    let source = param[0];
    let target = param[1];
    let set = state.invIndex.get(target);
    if (set !== undefined) {
      set.delete(source);
      if (set.size === 0) {
        state.invIndex.delete(target);
        return;
      } else {
        return;
      }
    }
  });
  delta.removedFromBase.forEach(x => {
    state.base.delete(x);
  });
  let contractionWorklist = new Set();
  delta.removedFromBase.forEach(x => {
    if (state.current.has(x)) {
      contractionWorklist.add(x);
      return;
    }
  });
  delta.removedFromStep.forEach(param => {
    let target = param[1];
    if (state.current.has(param[0]) && state.current.has(target)) {
      contractionWorklist.add(target);
      return;
    }
  });
  let removedSet = new Set();
  if (contractionWorklist.size > 0) {
    let removed = contract(state, contractionWorklist);
    removed.forEach(x => {
      allRemoved.push(x);
      removedSet.add(x);
    });
  }
  delta.addedToStep.forEach(param => addToInvIndex(state, param[0], param[1]));
  delta.addedToBase.forEach(x => {
    state.base.add(x);
  });
  let expansionFrontier = new Set();
  delta.addedToBase.forEach(x => {
    if (!state.current.has(x)) {
      expansionFrontier.add(x);
      return;
    }
  });
  delta.addedToStep.forEach(param => {
    let target = param[1];
    if (state.current.has(param[0]) && !state.current.has(target)) {
      expansionFrontier.add(target);
      return;
    }
  });
  if (removedSet.size > 0) {
    removedSet.forEach(y => forEachStepInv(state, y, x => {
      if (state.current.has(x)) {
        expansionFrontier.add(y);
        return;
      }
    }));
  }
  if (expansionFrontier.size > 0) {
    let added = expand(state, expansionFrontier);
    added.forEach(x => {
      allAdded.push(x);
    });
  }
  let netRemoved = [];
  allRemoved.forEach(x => {
    if (!state.current.has(x)) {
      netRemoved.push(x);
      return;
    }
  });
  let netAdded = [];
  allAdded.forEach(x => {
    if (!removedSet.has(x)) {
      netAdded.push(x);
      return;
    }
  });
  return {
    added: netAdded,
    removed: netRemoved
  };
}

function debugInfo(state) {
  return {
    current: state.current.values().toArray(),
    ranks: state.rank.entries().toArray(),
    base: state.base.values().toArray(),
    invIndexSize: state.invIndex.size
  };
}

export {
  emptyDelta,
  emptyChanges,
  make,
  current,
  rank,
  has,
  size,
  applyDelta,
  debugInfo,
}
/* No side effect */
