// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fixpoint from "./Fixpoint.res.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";
import * as Belt_SetString from "@rescript/runtime/lib/es6/Belt_SetString.js";

function make(base) {
  let stepRelation = {
    contents: undefined
  };
  let config = {
    stepFwd: source => {
      let stepRelation$1 = stepRelation.contents;
      return Belt_SetString.toArray(Belt_MapString.getWithDefault(stepRelation$1, source, undefined));
    }
  };
  let fixpointState = Fixpoint.make(config, base);
  return {
    stepRelation: stepRelation,
    fixpointState: fixpointState
  };
}

function addToBase(t, element) {
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: [element],
    removedFromBase: Fixpoint.emptyDelta.removedFromBase,
    addedToStep: Fixpoint.emptyDelta.addedToStep,
    removedFromStep: Fixpoint.emptyDelta.removedFromStep
  });
}

function removeFromBase(t, element) {
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: Fixpoint.emptyDelta.addedToBase,
    removedFromBase: [element],
    addedToStep: Fixpoint.emptyDelta.addedToStep,
    removedFromStep: Fixpoint.emptyDelta.removedFromStep
  });
}

function addToStep(t, source, target) {
  let existing = Belt_MapString.getWithDefault(t.stepRelation.contents, source, undefined);
  t.stepRelation.contents = Belt_MapString.set(t.stepRelation.contents, source, Belt_SetString.add(existing, target));
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: Fixpoint.emptyDelta.addedToBase,
    removedFromBase: Fixpoint.emptyDelta.removedFromBase,
    addedToStep: [[
        source,
        target
      ]],
    removedFromStep: Fixpoint.emptyDelta.removedFromStep
  });
}

function removeFromStep(t, source, target) {
  let existing = Belt_MapString.getWithDefault(t.stepRelation.contents, source, undefined);
  let newSet = Belt_SetString.remove(existing, target);
  if (Belt_SetString.isEmpty(newSet)) {
    t.stepRelation.contents = Belt_MapString.remove(t.stepRelation.contents, source);
  } else {
    t.stepRelation.contents = Belt_MapString.set(t.stepRelation.contents, source, newSet);
  }
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: Fixpoint.emptyDelta.addedToBase,
    removedFromBase: Fixpoint.emptyDelta.removedFromBase,
    addedToStep: Fixpoint.emptyDelta.addedToStep,
    removedFromStep: [[
        source,
        target
      ]]
  });
}

function applyChanges(t, addedToBaseOpt, removedFromBaseOpt, addedToStepOpt, removedToStepOpt) {
  let addedToBase = addedToBaseOpt !== undefined ? addedToBaseOpt : [];
  let removedFromBase = removedFromBaseOpt !== undefined ? removedFromBaseOpt : [];
  let addedToStep = addedToStepOpt !== undefined ? addedToStepOpt : [];
  let removedToStep = removedToStepOpt !== undefined ? removedToStepOpt : [];
  addedToStep.forEach(param => {
    let source = param[0];
    let existing = Belt_MapString.getWithDefault(t.stepRelation.contents, source, undefined);
    t.stepRelation.contents = Belt_MapString.set(t.stepRelation.contents, source, Belt_SetString.add(existing, param[1]));
  });
  removedToStep.forEach(param => {
    let source = param[0];
    let existing = Belt_MapString.getWithDefault(t.stepRelation.contents, source, undefined);
    let newSet = Belt_SetString.remove(existing, param[1]);
    if (Belt_SetString.isEmpty(newSet)) {
      t.stepRelation.contents = Belt_MapString.remove(t.stepRelation.contents, source);
    } else {
      t.stepRelation.contents = Belt_MapString.set(t.stepRelation.contents, source, newSet);
    }
  });
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: addedToBase,
    removedFromBase: removedFromBase,
    addedToStep: addedToStep,
    removedFromStep: removedToStep
  });
}

function has(t, element) {
  return Fixpoint.has(t.fixpointState, element);
}

function current(t) {
  return Fixpoint.current(t.fixpointState);
}

function rank(t, element) {
  return Fixpoint.rank(t.fixpointState, element);
}

function size(t) {
  return Fixpoint.size(t.fixpointState);
}

function debugInfo(t) {
  let info = Fixpoint.debugInfo(t.fixpointState);
  return {
    current: info.current,
    ranks: info.ranks,
    base: info.base,
    stepRelationSize: Belt_MapString.size(t.stepRelation.contents)
  };
}

export {
  make,
  addToBase,
  removeFromBase,
  addToStep,
  removeFromStep,
  applyChanges,
  has,
  current,
  rank,
  size,
  debugInfo,
}
/* No side effect */
