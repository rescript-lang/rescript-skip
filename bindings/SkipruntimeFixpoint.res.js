// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fixpoint from "./Fixpoint.res.js";

function make(base) {
  let stepRelation = {
    contents: new Map()
  };
  let config = {
    stepFwdForEach: (source, f) => {
      let stepRelation$1 = stepRelation.contents;
      let targets = stepRelation$1.get(source);
      if (targets !== undefined) {
        targets.forEach(f);
        return;
      }
    }
  };
  let fixpointState = Fixpoint.make(config, base);
  return {
    stepRelation: stepRelation,
    fixpointState: fixpointState
  };
}

function addToBase(t, element) {
  let init = Fixpoint.emptyDelta();
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: [element],
    removedFromBase: init.removedFromBase,
    addedToStep: init.addedToStep,
    removedFromStep: init.removedFromStep
  });
}

function removeFromBase(t, element) {
  let init = Fixpoint.emptyDelta();
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: init.addedToBase,
    removedFromBase: [element],
    addedToStep: init.addedToStep,
    removedFromStep: init.removedFromStep
  });
}

function addToStep(t, source, target) {
  let set = t.stepRelation.contents.get(source);
  let existing = set !== undefined ? set : new Set();
  existing.add(target);
  t.stepRelation.contents.set(source, existing);
  let init = Fixpoint.emptyDelta();
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: init.addedToBase,
    removedFromBase: init.removedFromBase,
    addedToStep: [[
        source,
        target
      ]],
    removedFromStep: init.removedFromStep
  });
}

function removeFromStep(t, source, target) {
  let existing = t.stepRelation.contents.get(source);
  if (existing !== undefined) {
    existing.delete(target);
    if (existing.size === 0) {
      t.stepRelation.contents.delete(source);
    }
  }
  let init = Fixpoint.emptyDelta();
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: init.addedToBase,
    removedFromBase: init.removedFromBase,
    addedToStep: init.addedToStep,
    removedFromStep: [[
        source,
        target
      ]]
  });
}

function applyChanges(t, addedToBaseOpt, removedFromBaseOpt, addedToStepOpt, removedToStepOpt) {
  let addedToBase = addedToBaseOpt !== undefined ? addedToBaseOpt : [];
  let removedFromBase = removedFromBaseOpt !== undefined ? removedFromBaseOpt : [];
  let addedToStep = addedToStepOpt !== undefined ? addedToStepOpt : [];
  let removedToStep = removedToStepOpt !== undefined ? removedToStepOpt : [];
  addedToStep.forEach(param => {
    let source = param[0];
    let set = t.stepRelation.contents.get(source);
    let existing = set !== undefined ? set : new Set();
    existing.add(param[1]);
    t.stepRelation.contents.set(source, existing);
  });
  removedToStep.forEach(param => {
    let source = param[0];
    let existing = t.stepRelation.contents.get(source);
    if (existing !== undefined) {
      existing.delete(param[1]);
      if (existing.size === 0) {
        t.stepRelation.contents.delete(source);
        return;
      } else {
        return;
      }
    }
  });
  return Fixpoint.applyDelta(t.fixpointState, {
    addedToBase: addedToBase,
    removedFromBase: removedFromBase,
    addedToStep: addedToStep,
    removedFromStep: removedToStep
  });
}

function has(t, element) {
  return Fixpoint.has(t.fixpointState, element);
}

function current(t) {
  return Fixpoint.current(t.fixpointState);
}

function rank(t, element) {
  return Fixpoint.rank(t.fixpointState, element);
}

function size(t) {
  return Fixpoint.size(t.fixpointState);
}

function debugInfo(t) {
  let info = Fixpoint.debugInfo(t.fixpointState);
  return {
    current: info.current,
    ranks: info.ranks,
    base: info.base,
    stepRelationSize: t.stepRelation.contents.size
  };
}

export {
  make,
  addToBase,
  removeFromBase,
  addToStep,
  removeFromStep,
  applyChanges,
  has,
  current,
  rank,
  size,
  debugInfo,
}
/* No side effect */
