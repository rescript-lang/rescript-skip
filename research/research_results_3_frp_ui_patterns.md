# FRP and Reactive UI Aggregation Patterns

	1.	Reactive-banana FRP (Counter) – Apfelmus’s FRP example defines a counter Behavior that accumulates button click events (increment/decrement) into a running total ￼ ￼. The state (an integer counter per UI component) is updated by folding event increments, which is a straightforward event-collection with a sum reducer – “natural fit for Skip collection+reducer.”
	2.	Yampa FRP (Event Count) – Yampa’s library provides combinators like count that accumulate the number of occurrences of an input event over time ￼ ￼. This yields a continuously updated count (e.g. a global or local event counter), modeled by adding 1 for each event – a simple aggregation of events – “natural fit for Skip collection+reducer.”
	3.	Elm (foldp Click Counter) – In Elm’s older signal FRP, foldp (“fold from the past”) is used to keep a running count of events. For example, counting mouse clicks involves folding a function (\_ n -> n+1) over an initial 0 and the click signal ￼ ￼. The result is a continuously updating counter (here at app level) that sums event occurrences – “natural fit for Skip collection+reducer.”
	4.	Elm Architecture (Undo/Redo History) – An Elm architecture example (a drawing app) maintains a history list of past states and a current index for undo/redo ￼ ￼. Each new action adds a state snapshot and moving the index back/forward implements undo or redo. This is a global app-state summary of all past states, requiring ordered sequencing and trimming of future states on new actions – “needs windows/time” (explicit time-indexed history rather than a simple reducer).
	5.	Fran/Fruit FRP (Text Input with Clear) – In classic FRP UI, state can be aggregated with reset semantics. For example, a text field that accumulates typed characters and clears on a “Clear” button click effectively maintains a rolling history of input within each interval between clear events ￼. The text is accumulated locally until a reset event empties it, defining a new window of aggregation. This reliance on an event to delimit accumulation means the summary (current text) depends on temporal order (clear breaks) – “needs windows/time” semantics.
	6.	Redux (Time-Travel/Undo) – Redux’s undo/redo recipe treats history as part of state by storing past, present, and future state slices ￼. For example, a counter’s state can be wrapped in an object with past: [...], present: 10, future: [], updating as the user undoes or redoes ￼. This is a global state history aggregator that records each state in sequence; because it explicitly tracks timeline order and discards “future” states on new input, it behaves like a timeline state machine – “needs windows/time” (state managed as an ordered history, beyond a simple reducer).
	7.	Redux (Shopping Cart Total) – In a Redux-managed cart, the total price is typically derived by summing over the collection of cart items. For instance, one can compute the total in a selector by reducing an array of {price, quantity} items into a single sum ￼ ￼. This derived state (cart total, at global store level) is just a pure reduction of a collection (sum of item subtotals) – “natural fit for Skip collection+reducer.”
	8.	React useReducer (Multiple Scores) – A React example uses the useReducer hook to manage an array of players with scores, updating the appropriate player’s score on an “INCREASE” action ￼ ￼. The state here is a collection of counters (scores per player, within a component or context), updated via a reducer that maps an increment over the matching item. This consolidates state updates in one place and sums changes per player, aligning with a collection + update function model – “natural fit for Skip collection+reducer.”
	9.	RxJS (Sliding Window of Events) – Using RxJS, one can maintain a rolling window of recent events. For example, a custom operator or the buffer/count operators can collect the last N events every time a new event arrives ￼ ￼. This yields an aggregated list (or a running calculation like a moving average) over a sliding timeframe or count window. Because the summary state (e.g. list of last 3 events) depends on the temporal order and expiring of old events, it inherently requires windowing semantics – “needs windows/time.”
	10.	Svelte (Derived Store for Cart Total) – Svelte stores allow derived values. For example, given a writable store cart (array of items), one can define a derived store total = derived(cart, $cart => $cart.reduce((s,i)=> s + i.price, 0)) ￼ ￼. This computed total (e.g. sum of item prices, perhaps global if the store is global) stays updated as the cart changes. It’s effectively a reducer (summing) applied reactively to a collection – “natural fit for Skip collection+reducer.”
	11.	Vue (Computed Sum of Products) – In Vue, a common pattern is to use a computed property to derive a summary from reactive data. For instance, given a productList of items with an amount field, one can define a computed property that loops or reduces over the list to calculate the total amount ￼. This computed total (within a component) updates whenever the list changes. It’s simply an aggregation of a collection via addition – “natural fit for Skip collection+reducer.”
	12.	Vue (Computed Average Rating) – Vue can also derive summaries like an average over a collection. For example, given a list of review objects with score, a component can compute the average score by summing all v.score and dividing by the count ￼ ￼. This derived summary (average of reviews, component-local) is calculated with a reduction (sum) and is cached/reactively updated by Vue. It’s a pure function of the collection state – “natural fit for Skip collection+reducer.”
	13.	MobX (Computed Order Total) – MobX uses computed values to derive state. For example, an OrderLine class with observable price and amount fields can define a getter total that returns price * amount ￼ ￼. MobX will recalc and cache this whenever price or amount changes. Here the aggregation is trivial (product of two observables, per object), but in larger stores you could similarly compute, say, an unread message count by filtering an observable list. In all cases the summary is defined as a function of observable collections or values – “natural fit for Skip collection+reducer.”
	14.	Svelte (Undoable Store with History) – A Svelte implementation of undo/redo maintains a history stack of state snapshots and an index pointer ￼ ￼. Each time state changes (e.g. drawing a new circle in a canvas), it calls an update() that pushes a new snapshot and truncates any “redo” states. The store provides undo()/redo() that simply decrement or increment the index to set the current state to a previous snapshot. This pattern (used as a global store) explicitly handles ordered state sequences and windowing of history, acting more like an explicit state machine or timeline of states – “needs windows/time” (history management beyond a simple reducer).
	15.	SolidJS (Derived Signal Value) – Solid’s fine-grained reactivity allows on-the-fly derived state. For example, rather than storing a separate doubleCount, one can use a derived signal: const doubleCount = () => count() * 2 and directly use doubleCount() in the JSX ￼. This derived value (component-level) automatically reflects the current count. While this specific case is a simple functional transformation (doubling a single state), it illustrates Solid’s approach to computed state as a pure function of signals – “natural fit for Skip collection+reducer” for any scenario where state can be derived by a deterministic reducer over reactive inputs.