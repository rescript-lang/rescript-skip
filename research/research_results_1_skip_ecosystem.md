# Skip Ecosystem Aggregation Catalogue

Simple Aggregation Patterns (Fully Invertible Reducers)
	•	Active members per group – Docs (Skip “Writing functions”): Counts the number of active users in each group. Implemented by mapping active user IDs then using a Count reducer. For example, activeMembers.map(NumActiveMembers) yields a collection GroupID → count of active users ￼. (a) Fully invertible (each added/removed user increments or decrements the count). State: simple integer per group (accumulator starts at 0).
	•	Total sales by category – Blog (Backend Pressure): Sums a numeric value across items grouped by category. For example, an e-commerce service maintains category aggregations so that price changes update the total revenue or inventory count per category in real-time ￼. This uses a Sum reducer after mapping each sale to its category. (a) Invertible (adds new sale amounts, subtracts on removal). State: single numeric total per category (e.g. running sum).
	•	Portfolio value by sector – Blog (Backend Pressure): A finance example where position updates flow into sector-level totals. Each stock position (shares × price) is mapped to its sector, then a Sum reducer maintains the sector aggregations (e.g. total portfolio value per sector) ￼. (a) Invertible (recompute by adding/removing one position’s value). State: one number per sector.
	•	Groups-per-user index – Docs (Skip mapping example): An inverted index that collects all group IDs a user belongs to. Achieved by mapping each group’s member list into (user → group) pairs ￼ ￼. The Skip runtime automatically aggregates multiple outputs with the same key, producing an EagerCollection<UserID, GroupID> where each user key is associated with all their groups. (a) Invertible (adding/removing a group membership inserts or deletes one entry under that user). State: list of group IDs per user (maintained as a collection of values).
	•	Active user count (global) – Conceptual: Computes a single total (e.g. number of active users across the service). Achievable by mapping all users to a constant key and reducing with Count. This yields a one-key collection (“all” → activeCount). (a) Invertible via Count (increment on activation, decrement on deactivation) ￼. State: one integer.

Partial or Composite-State Aggregates (Partial Inverse or Enriched State)
	•	Max value per key – API (Skip helpers Max): Maintains the maximum of all values for each key (e.g. highest score or latest timestamp in a collection) ￼. Implemented with a Max reducer. (b) Naturally partial: If the current max is removed, the reducer may return null to fall back on recomputing the new max from all remaining values ￼. In other cases (removed value < current max), it updates in place. State: a single number (current max) per key.
	•	Min value per key – API (Skip helpers Min): Tracks the minimum value (e.g. lowest price or earliest date) ￼. Similar to Max, removal of the min may trigger a full recompute ￼. (b) Partial inverse (efficient for non-extremal removals, falls back otherwise). State: single number (current min).
	•	Average rating per item – Conceptual: Calculates an average from many values (e.g. product star ratings). One pattern is to use an enriched state reducer that accumulates (sum, count) and outputs sum/count. This custom Reducer<number, number> would initialize with {sum:0,count:0}, add by adding the new value and incrementing count, and remove by subtracting and decrementing. If implemented fully, it can uphold the Skip inverse consistency rules ￼ and avoid full recomputation. (b) (Partial if implemented naïvely as just an average; (a) if storing extra state to make it invertible). State: pair of numbers per key (sum and count) – effectively an enriched accumulator.
	•	Distinct count (unique values) – Conceptual: Counts unique occurrences (e.g. unique visitors per day). A reducer can maintain a set of seen values and its size. Increments are straightforward, but removals require tracking duplicates. For example, if using a set, removing a value might need a full recompute if that value occurred multiple times (to check if others remain). (b) Typically partial – to be safe, remove() might return null to recompute the unique count ￼ ￼, unless a reference count per value is kept. State: enriched (set or map of frequencies).
	•	Histogram / frequency distribution – Conceptual: Aggregates values into buckets (e.g. distribution of ages or transaction amounts). Can be done with a reducer that maintains a map of bucket → count. Add: increment the count for the corresponding bin; Remove: decrement the bin count (or recompute if a bin goes to zero). If implemented with complete tracking of counts, it can be mostly invertible. (a) Invertible in principle (since each removal’s effect is known per bin), though the state is a composite object (the histogram). State: dictionary of counts (one per bucket) for each key’s group of values.

Complex & Holistic Patterns (Outside the Basic Reducer Model)
	•	Sliding time-window aggregates – Conceptual: E.g. “last 1 hour of events” or moving window sums. Skip’s model doesn’t intrinsically handle time-based eviction – such logic is external to the reactive graph. One could model time windows by keying entries with time and using range queries (slice() by time keys to restrict data ￼), but to continuously “slide” a window, the service must explicitly remove out-of-window entries (triggering removals in the collection). This is (c) outside the built-in reducer model – it requires ordered data and timed invalidation which Skip doesn’t automate. State: window contents (effectively the subset of the collection within the time range).
	•	Session-based aggregation – Conceptual: E.g. computing metrics per user session (where sessions are defined by a sequence of events with idle gaps). This cannot be expressed as a simple key-based reducer without embedding session logic. The system would need to detect session boundaries and possibly re-key data per session. Thus it lies (c) outside the pure functional-reactive model. State: would need to accumulate events until a session ends (requires buffering and flushing on boundaries).
	•	Top-N ranking – Conceptual: Maintaining a top K list (e.g. top 10 products by sales). This requires ordering values by a metric. A custom reducer could keep a sorted list or min-heap of the top N. Insertion is manageable (compare and insert if qualifies), but removal of an arbitrary item (especially if it’s outside the top N) might not be tracked unless the entire dataset is known. Likely one would recompute the top-N from scratch on any removal for correctness. (c) Holistic – not naturally supported by a simple add/remove model (requires global ordering). State: list of top N items (and potentially additional state to compare incoming values against the threshold).
	•	Median/percentile – Conceptual: Calculating a median value of a collection is a holistic operation. There’s no efficient small “inverse” update – the median can shift dramatically when any value is added or removed. One would effectively need to maintain a sorted structure of all values or use an approximation. In Skip, this would likely be handled by always returning null on removal (triggering a full recompute via re-adding all values) or delegating to an external computation. (c) outside the reducer model’s efficient support. State: essentially the entire sorted dataset (or complex data structure) to pick the median.

Summary – Common Patterns: Across Skip’s ecosystem, a few aggregation patterns recur. Simple totals and counts (e.g. summing values, counting items) are ubiquitous – they appear in examples like real-time dashboards, performance metrics, and category totals, and Skip provides built-in reducers like Count and Sum for these common cases ￼ ￼. Grouping and indexing of data (e.g. building lists of entities by key) is another frequent pattern, achieved by mapping collections (as seen with user–group memberships and search indices). For more advanced aggregates, developers often combine basic ones – for instance, computing an average by using both a sum and a count aggregator. Skip’s incremental compute model excels when an aggregate can be updated with localized changes – many business metrics (sums, counts, min/max, etc.) fall in this category and can be expressed as well-formed reducers with inverses. However, holistic computations that depend on global ordering or all data (like top-k, medians, or time-windowed stats) are not directly provided as built-ins. In such cases, one must either use richer state (storing more information to handle updates) or accept partial recomputation ￼. These patterns are recognized in Skip’s design: the system allows reducers to signal when they cannot incrementally handle a removal (remove() returning null to recompute) ￼. In practice, this means simple aggregates are handled efficiently and automatically, while complex aggregations (windows, sessions, percentiles) require additional logic or fallbacks – matching the trade-offs noted in Skip’s documentation and blog discussions on reactive system design ￼ ￼.