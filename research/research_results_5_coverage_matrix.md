# Expressivity Coverage Matrix

Expressivity Coverage in a Skip-Style Reactive Calculus

Coverage Matrix: The table below categorizes example computations into five families and estimates what fraction of each is naturally expressible as (a) well-formed per-key reducers with invertible updates, (b) partial (not fully invertible) reducers requiring occasional recompute, or (c) needing new combinators beyond reducers (e.g. windowing or iterative algorithms).

Example Family	Well-Formed Reducers (invertible)	Partial Reducers (fallback)	New Combinators Required
Simple Per-Key Aggregates	~90% (e.g. sum, count, avg)	~10% (e.g. min/max if not storing full state)	~0%
Enriched-State Aggregates	~70% (e.g. avg with sum&count, histograms) ￼	~20% (e.g. exact distinct count, precise quantiles)	~10%
Windowed/Session-Based Aggregates	~20% (simple tumbling windows via invertible aggregators)	~30% (some sliding-window cases with partial state)	~50% (most sliding/session windows) ￼
Graph/Relational Aggregates	~20% (trivial counts or degrees per node)	~30% (incremental but complex e.g. join+aggregate)	~50% (iterative graph algorithms, recursive queries)
Business Metrics & UI/State Patterns	~50% (simple KPIs, counters, UI folds)	~30% (multi-stream or conditional metrics)	~20% (funnel analytics, dynamic UI flows)

Key Observations:
	1.	Prioritize Well-Formed Reducers: The majority of simple and enriched aggregates in real-time analytics are distributive or algebraic in Gray’s taxonomy ￼ – e.g. sums, counts, averages (with sum & count), and small-state combiners like histograms. These should be well-formed by construction in Skip’s calculus, meaning they maintain enough state to support invertible updates (add/remove) and compose efficiently. Focusing on these common patterns (e.g. per-key sums/counts, running averages, min/max with retained secondary state) covers a large portion of use cases. By building these as first-class incremental reducers, the calculus can handle ~70–90% of basic analytics and UI state updates without full recomputation.
	2.	Accept Partial Reducers for Holistic Cases: A significant minority of aggregates are holistic (no fixed-size state ￼) or otherwise non-invertible in practice – for example, exact min/max, distinct counts, medians/quantiles, or top-K lists. These often cannot be maintained purely by adding and subtracting individual updates unless one keeps extensive state or uses approximation. In practice, min, max, first/last, distinct, argmax and similar aggregations are known to be non-invertible without extra data structures ￼. Skip’s calculus should not attempt to fully incrementalize these by default. Instead, it can treat them as partial reducers with fallback: maintain whatever partial state is feasible (or an approximate summary), but allow the system to recompute from scratch or use a heavier algorithm when needed for correctness ￼. This strategy acknowledges that ~10–30% of advanced aggregations (e.g. exact distinct user counts or precise percentiles) are best handled with either occasional recomputation or approximate methods, rather than complicating the core model.
	3.	Introduce New Combinators for Windows and Sessions: Temporal aggregations (tumbling/sliding windows, session-based metrics) form a distinct family that a pure reducer cannot cover alone. Windows are a central concept in streaming systems – they limit infinite streams into recent data slices ￼ – and typically require the framework to manage event expiration or grouping by time. Skip’s reactive calculus should provide explicit windowing combinators (for fixed windows, sliding windows with eviction, session gaps, etc.), rather than forcing every windowed query into a single reducer. Many windowed examples (estimated ~50%) need such built-in support. Even when using invertible reducers (e.g. subtracting old values for a sliding sum), a window operator or time-based trigger is needed to supply those removals. By adding window/session operators as first-class primitives, Skip can handle time-bounded aggregates (rolling averages, session lengths, moving counts) cleanly, leaving only a smaller portion (~20–30%) that might be approximated or partially updated without dedicated window logic.
	4.	Extend Beyond Reducers for Graph & Complex Queries: A number of relational or graph-derived computations are not naturally expressible as one-step per-key reductions at all. Examples include incremental joins, graph traversal algorithms (connected components, PageRank), or multi-step business metrics (e.g. conversion funnels correlating events). These often require combining streams or iterative propagation. Skip’s calculus should recognize when new combinators or operators are needed – for instance, a join/merge operator to combine multiple keyed collections, or a fixpoint/loop combinator to handle iterative graph algorithms and recursive queries. Such features address the ~50% of complex examples (like dynamic graph analytics or multi-source metrics) that fall outside the scope of a single reducer. In other words, Skip should focus on reducers for the bulk of simple cases, but also provide hooks for compositional queries and iteration (as seen in incremental view maintenance and dataflow systems) to broaden its expressivity.
	5.	Focus of Reactive UI Patterns: In the UI/state domain, many patterns (like form input tracking, live counters, or list updates) map to incremental folds or simple aggregations on event streams – which the reducer model handles well. However, some interactive patterns (e.g. multi-step workflows or conditional UI updates) resemble switches or triggers rather than pure accumulations. The calculus should support combining multiple reactive streams or toggling subscriptions explicitly. Fortunately, functional reactive programming shows that most UI state can be managed by a combination of stream merges, maps, and folds (for state accumulation), so making those primitives ergonomic covers the majority. Only specialized cases (complex event choreography or undo logic) would step outside, and those can be handled with higher-level state machines or left to recompute on changes. Overall, Skip should emphasize well-formed accumulators for UI state and allow more complex event patterns to use specialized constructs as needed, rather than contorting the reducer abstraction for everything.